#!/usr/bin/env python3
# Mandatory imports
import argparse
import os

# Checking for 'pandas' package
try:
    import pandas
except ImportError:
    raise ImportError("Missing package: `PANDAS`!")


def reverse_translate(amino, codon_table):
    """
    Reverse-translates aminoacid back to the most used codon from codon table.
    """
    temp_values = []
    temp_triplets = []

    for i, row in codon_table.loc[codon_table[0] == amino].iterrows():
        temp_triplets.append((row[1]).strip().upper())
        temp_values.append(row[2])
    
    return temp_triplets[temp_values.index(max(temp_values))]


def make_dna_triplets(string):
    """
    Makes chunks of 3 characters from a long string.
    """
    return [string[start:start+3] for start in range(0, len(string), 3)]


def codon_optimize(sequence_id, cds, codon_table, force):
    """
    Checks if a given sequence starts with the start codon ('ATG') and promts you if it doesn't.
    Optimizes codons to most frequently used from the codon table.
    """
    run = True

    if cds[:3] != "ATG":
        if not force:
            run = prompt_force(sequence_id, cds[:3])
            force = True
    else:
        force = False

    if run:
        optimized_cds = ""

        for triplet in make_dna_triplets(cds):
            
            if len(triplet) == 3:
                optimized_cds += reverse_translate(codon_table.loc[
                    codon_table[1] == triplet][0].iloc[0][0], codon_table)
            else:
                optimized_cds += triplet

        return optimized_cds, force
    
    else:
        return False, force


def writer(dictionary, path=None):
    """
    Simple function for writing `.fasta` files.
    Translates dictionary into a fasta file and writes it to a file. If no path is given,
    it returns only translated string.
    """
    string = ""

    for k, v in dictionary.items():
            if v[0]:
                k += "|OPTIMIZED"
                if v[1]:
                    k += "|forced"
                string += "{0}\n{1}\n\n".format(k, v[0])

    if path:
        with open(path, 'w') as file_out:
            file_out.write(string)
    else:
        return string


def open_fasta(file_input_path):
    """
    Function for opening `.fasta` files. Files can contain multiple sequences.
    Returns dictionary of sequences ==> {id: sequence}
    """
    sequence_dictionary = {}

    with open(file_input_path, 'r') as input_file:
        data = input_file.readlines()
    
    for line in data:
        temp = line.strip()
        if line[0] == ">":
            sequence_id = temp[:20]
            sequence_dictionary[sequence_id] = ""
        else:
            sequence_dictionary[sequence_id] += temp.upper()

    return sequence_dictionary


def protein_to_dna(sequences, codon_table):
    """
    Translates protein to dna with a call to reverse_translate() function.
    """
    reverse_translations = {}

    for sequence_id, sequence in sequences.items():
        reverse_translations[sequence_id] = ["", None]

        for amino in sequence:
            reverse_translations[sequence_id][0] += reverse_translate(amino, codon_table)
    
    return reverse_translations


def dna_operation(sequences, codon_table, force, optimize=None):
    """
    Optimizes DNA triplets to use most common codons from the codon_table.
    """
    solutions = {}

    if optimize:
        for sequence_id, sequence in sequences.items():
            solutions[sequence_id] = codon_optimize(sequence_id, sequence, codon_table, force)
    else:
        for sequence_id, sequence in sequences.items():
            solutions[sequence_id] = translate_dna(sequence_id, sequence, codon_table, force)
    
    return solutions


def prompt_force(sequence_id, first_triplet):
    cont_prompt = input("Sequence with ID `{0}` is not a CDS, optimize anyway? (Y/n): ".format(sequence_id))
    
    if cont_prompt.upper() == "Y" or cont_prompt.upper() == "YES" or cont_prompt == "":
        return True
    else:
        return False


def translate_dna(sequence_id, cds, codon_table, force):
    """
    Translates coding DNA sequence to protein sequence.
    """
    run = True

    if cds[:3] != "ATG":
        if not force:
            run = prompt_force(sequence_id, cds[:3])
            force = True
    else:
        force = False

    if run:
        translation = ""

        for triplet in make_dna_triplets(cds):
            
            if len(triplet) == 3:
                translation += codon_table.loc[codon_table[1] == triplet][0].iloc[0][0]
            else:
                translation += "?"

        return translation, force

    else:
        return False, force


def main():
    """
    Main function with argument parsing.
    """
    description = ("Welcome to python script for converting protein sequence to DNA sequence with\
                    custom table for codon usage.")

    # Arguments
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-i", "--input", help="Path to input 'fasta' file", required=True)
    parser.add_argument("-t", "--table",help="Path to codon usage table in csv format: 'aminoacid,triplet,value')", required=True)
    parser.add_argument("-p", "--protein", action="store_true", help="Use this flag when working with protein sequences", required=False)
    parser.add_argument("-o",  "--output", help="Name for the output fasta file", required=False)
    parser.add_argument("-f", "--force", action="store_true", help="Use this flag to omit any prompts", required=False)
    parser.add_argument("-O", "--optimize", action="store_true", help="Use to optimize DNA sequence instead translating it.", required=False)
    args = parser.parse_args()

    # Variables
    path_fasta = os.path.join(os.path.join(os.getcwd(), args.input))
    path_table = os.path.join(os.path.join(os.getcwd(), args.table))
    codon_table = pandas.read_csv(path_table, header=None)
    sequences = open_fasta(path_fasta)

    # Protein translation
    if args.protein:
        solution = protein_to_dna(sequences, codon_table)

    elif not args.protein:
        solution = dna_operation(sequences, codon_table, args.force, args.optimize)

    # Saving/Printing solution(s)
    if args.output:
        path_save = os.path.join(os.path.join(os.getcwd(), args.output))
        msg_saved = "Output saved to `{0}`".format(args.output)
        writer(solution, path_save)
        print(msg_saved)
    else:
        print()
        print(writer(solution))


if __name__ == "__main__":
    main()


# a = open_fasta("test_data/multi_dna.fasta")
# t = pandas.read_csv("test_data/table.csv", header=None)
# f = False
# z = True
# # z = False


# x = dna_operation(a, t, f, z)
# y = writer(x)

# print(y)